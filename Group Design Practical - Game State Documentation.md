# Game State Documentation

There are 3 different code files – one for each of Square, Cell and Board. The code has been commented to reflect some of the below information.

The Square (struct) represents a Picross square, it consists only of one member, a number (from 1-16 for every potential block size) giving the size of some particular non-mine block in its row/column. The struct has a constructor which can be used upon instantiation to assign its number immediately. The Squares are not meant to be clickable. It is a struct and not a class – this means it is a value type not a reference type. So, if it is modified, this change is not reflected in every place where the instance is located but this is fine, since it cannot be modified (and does not need to be). Each randomly chosen row/column will have potentially multiple Square objects associated with it – one for each contiguous block of non-mine squares in that row/column.

The Cell (class) represents a clickable cell (which occur in the original Minesweeper too). This has a member revealed as a boolean for if the cell is hidden or not. There is a number member also – with numbers 1-8 (for number of adjacent mines) with numbers 0, -1, 9 assigned to cells that are empty (no adjacent mines), mines or are unknown (represented with a ?) respectively. There is also a flagged member, a boolean for if the cell has been flagged or not.

The Board (class) has a few different members and methods – I will list only the ones that will be of use to you. The class is able to interact directly with the Tilemap (the visual representation of the game). As such, the methods of use are the draw methods – there are 3 of these. The drawSquare method takes 3 arguments – a Square object, and two coordinates (i,j). This is used to visually draw the square in its corresponding location (and should only be called once for each Square, since the Squares are not supposed to be modified). The coordinates (i,j) represent the location of the Square relative to the Minesweeper grid (the clickable space) which is not including the Picross squares. That means that (2,2) refers to the clickable cell in the 3rd row and column of the clickable space. So, if there was a Square to the left of this cell (outside the clickable space) then its location would be (2,-1) meaning 2nd row, just outside to the left of the clickable space (representing the last block in the 2nd row). Similarly, (-1,2) would be above the 2nd column and (-2,2) would be 2 spaces above the 2nd column (representing the 2nd last block in that column). Similarly with 3 arguments, there is a drawCell method for Cell objects, with supplied coordinates relative to the clickable space. Make sure that this is called whenever a Cell’s visuals should be changed e.g. if it is revealed, flagged/unflagged etc. especially at the end of the game, where all the mines should be revealed. Finally, there is a drawGrid method with only 1 argument – a grid (a two-dimensional array of Cell objects) used to draw the entire clickable space (so not the Picross squares) in 1 method call. Since the whole space is being drawn, no coordinates need to be supplied. This is better to use if a considerable amount of the space has changed e.g. when revealing mines at the end, when setting up the cells at the start or when applying a “floodfill” during the game.

Remember that the clickable game space is a 16x16 grid of cells, with 50 mines. The game board is bigger than this, since it includes the Picross squares. Also note that when instantiating some objects, if those objects have members, those members are set to default values (I think the default value for Booleans in C# is false). This means that e.g. you might not have to manually set every cell’s revealed member as false (since all cells start off hidden) – I would double-check the default value information if you use this. Let me know if any clarification is needed, regarding this documentation or the written code files or if there is something important/very useful missing from the code.
